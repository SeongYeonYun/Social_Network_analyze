---
title: "소셜 네트워크 분석 기말 보고서"
author: "박규훤, 소다영, 윤성연"
date: '2020 7 1 '
output: word_document
---

```{r setup, include=F}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(kableExtra)
library(igraph)
```

## 주제

- 특정 감독이 어떤 배우와 많은 영화를 찍었고, 그 사람들이 어떤 특징을 가지는지 분석
- 감독과 배우, 배우와 배우 사이의 캐미를 확인
- 비슷한 상황의 감독이 선택한 배우들의 성향, 및 배우들의 조합 확인

## 데이터

### 출처

- KOBIS (영화관 입장권 통합 전산망)

    [`http://www.kobis.or.kr/kobis/business/mast/mvie/searchMovieList.do`](http://www.kobis.or.kr/kobis/business/mast/mvie/searchMovieList.do)

    ```{r robots_img, echo=F, fig.cap='로봇 배제 표준', out.width='50%'}
    knitr::include_graphics('report/robots.png')
    ```
    
### 소개

- KOBIS의 전국 영화 박스오피스, 영화 별 상세 정보, 관계자(감독, 주연 배우) 정보

    ```{r boxoffice_img, echo=F, fig.cap='박스오피스', out.width='100%'}
    knitr::include_graphics('report/boxoffice.png')
    ```
    
    ```{r detail_img, echo=F, fig.cap='영화 상세 정보', out.width='50%'}
    knitr::include_graphics('report/moviedetail.png')
    ```
    
    ```{r staff_img, echo=F, fig.cap='관계자 정보', out.width='50%'}
    knitr::include_graphics('report/staff.png')
    ```

### 크롤링

- Python을 이용하여 크롤링 진행 (crawling.ipynb 파일 별첨)
- 빈 값 및 영화 모음 등에 대해 간단한 전처리 진행

```{r preprocessing, results='hide'}
# 빈 값 및 영화 모음 등에 대한 전처리

Sys.setlocale('LC_ALL', 'C')
movie <- read.csv('movie_list.csv', encoding = 'UTF-8')
actor <- read.csv('staff_list.csv', encoding = 'UTF-8')
Sys.setlocale('LC_ALL', 'korean')

movie[str_detect(movie$genre,'.+분.+초$'),]$genre <- ''
movie[str_detect(movie$country,'.+분.+초$'),]$country <- ''
movie <- movie[!str_detect(movie$genre,'기타'),]
movie <- movie[movie$genre != '',]
actor <- actor[!is.na(actor$person_id),]

write.csv(movie, 'pre_movie.csv', row.names = F, fileEncoding = 'UTF-8')
write.csv(actor, 'pre_actor.csv', row.names = F, fileEncoding = 'UTF-8')
```

### 데이터 예시

```{r locale_c, echo=F, results='hide'}
Sys.setlocale('LC_ALL', 'C')
```

```{r load_data}
movie <- read.csv('pre_movie.csv', encoding = 'UTF-8', stringsAsFactors = F)
staff <- read.csv('pre_actor.csv', encoding = 'UTF-8', stringsAsFactors = F)
```

```{r locale_korean, echo=F, results='hide'}
Sys.setlocale('LC_ALL', 'korean')
```

```{r head_data, echo=F}
#knitr::kable(head(movie), caption = '영화 데이터')
#knitr::kable(head(staff), caption = '관계자 데이터')
head(movie)
head(staff)
```

### 개요

- 기간: 2010. 01. 01 ~ 2019. 12. 31
- 영화 데이터
    - 75개 국가, 20개 장르
    - 11880 x 7
- 관계자 데이터
    - 11738개 영화, 16706명 관계자
    - 35699 x 4

## 전처리

### 장르 분리

- 앞서 보인 영화 데이터와 같이, 한 영화가 다양한 장르에 포함되어 있음
- 따라서 단일 장르로 구성된 여러개의 영화 데이터로 재구성 과정이 필요

```{r split_genre}
movie <- movie %>% mutate(genre = strsplit(genre, ',')) %>% unnest(genre)
```

### 관계자 데이터 재구성

- 영화별 함께 출연 또는 작업한 관계자 사이의 연결을 데이터 프레임으로 재구성
- 감독과 주연배우 분리
  ```{r split_staff}
  actor <- staff %>% filter(person_category == 'actor')
  director <- staff %>% filter(person_category == 'director')
  ```
- 감독 - 배우 데이터
  - 영화 별 각 감독과 각 주연 배우 사이의 연결을 표현
  
  ```{r process_director_data}
  director_data <- merge(director[c('movie_id', 'person_id')], actor[c('movie_id', 'person_id')], by='movie_id')
  director_data['person_id.x'] <- paste0('D', director_data[['person_id.x']])
  director_data['person_id.y'] <- paste0('A', director_data[['person_id.y']])
  ```
  
  ```{r head_director, echo=F}
  head(director_data)
  ```
  
- 배우 - 배우 데이터
  - 영화 별 각 주연배우 사이의 연결을 표현
  
  ```{r process_actor_data}
  movie_temp <- unique(actor[1])[[1]]
  actor_comb <- data.frame()
  for (j in 1:length(movie_temp)) {
    tmp <- actor[actor$movie_id==movie_temp[j],4]
    if (length(tmp) > 1) {
      actor_comb <- rbind(actor_comb, data.frame(movie_id=movie_temp[j], t(combn(tmp,2))))
    }
  }
  ```
  
  ```{r head_actor, echo=F}
  head(actor_comb)
  ```

## 네트워크 생성

- 애니메이션, 액션, 코미디 등 20개의 장르와 통합 데이터에 대해, 각각 감독 - 배우 네트워크(이하 Director 네트워크, D네트워크)와 배우 - 배우 네트워크(이하 Actor 네트워크, A 네트워크) 생성

```{r create_networks}
graph_names <- c('d_animation', 'a_animation',
               'd_action', 'a_action',
               'd_comedy', 'a_comedy',
               'd_fanta', 'a_fanta',
               'd_melo', 'a_melo',
               'd_drama', 'a_drama',
               'd_mystery', 'a_mystery',
               'd_adventure', 'a_adventure',
               'd_thriller', 'a_thriller',
               'd_crime', 'a_crime',
               'd_family', 'a_family',
               'd_horor', 'a_horor',
               'd_scifi', 'a_scifi',
               'd_musical', 'a_musical',
               'd_war', 'a_war',
               'd_doc', 'a_doc',
               'd_hist', 'a_hist',
               'd_ero', 'a_ero',
               'd_show', 'a_show',
               'd_western', 'a_western')

categories <- c("애니메이션",
                "액션",
                "코미디",
                "판타지",
                "멜로/로맨스",
                "드라마",
                "미스터리",
                "어드벤처",
                "스릴러",
                "범죄",
                "가족",
                "공포(호러)",
                "SF",
                "뮤지컬",
                "전쟁",
                "다큐멘터리",
                "사극",
                "성인물(에로)",
                "공연",
                "서부극(웨스턴)")

# 네트워크 생성
for (i in 1:length(categories)) {
  staff_temp <- director_data[director_data$movie_id %in% movie[movie$genre == categories[i], ][['code']],]
  graph_temp <- graph_from_data_frame(staff_temp[2:3], directed=F)
  assign(graph_names[i*2-1], graph_temp)
  
  actor_temp <- actor_comb[actor_comb$movie_id %in% movie[movie$genre == categories[i],][['code']],]
  graph_temp2 <- graph_from_data_frame(actor_temp[2:3], directed=F)
  assign(graph_names[i*2], graph_temp2)
}

# 전체 네트워크 생성
staff_temp <- director_data
d_all <- graph_from_data_frame(staff_temp[2:3], directed=F)

actor_temp <- actor_comb
a_all <- graph_from_data_frame(actor_temp[2:3], directed=F)

graph_names <- c(graph_names, 'd_all', 'a_all')
```

## 시각화

- 생성된 42개의 네트워크에 대해 시각화

```{r visualization}
par(mfrow=c(2,4))
for (s in graph_names) {
  g <- get(s)

  gubun <- str_sub(V(g)$name, 1, 1)
  colors <- ifelse(gubun=='D', 'yellow', 'blue')
  sizes <- ifelse(gubun=='D', 2, 1)
  plot(g, main=s,
       #layout=layout.kamada.kawai, 
       vertex.size=sizes, vertex.color=colors, edge.arrow.size=0.01, vertex.label=NA)
  legend("bottomleft",c("배우","감독"),cex=0.7,fill=c('blue', 'yellow'),col=c('blue', 'yellow'),bty="n")
}
```

## 분석

- 모든 네트워크에 대해 노드 수(vcount), 연결 수(ecount), 밀도(edge_density), 추이성(transitivity), 3명이 서로 모두 연결된 그룹 수(triad300), 중심성(centr_degree) 등의 통계치와 컴포넌트를 계산하여 정리
- D네트워크는 A네트워크와 다르게 2부 네트워크이므로 D네트워크와 A네트워크를 나누어 분석

```{r stat_table, results='hide', warning=F}
graph_stat <- data.frame()
graph_comp <- list()
for (s in graph_names) {
  g <- get(s)
  graph_stat <- rbind(graph_stat, data.frame(graph=s, 
                                             vcount=vcount(g), 
                                             ecount=ecount(g),
                                             density_a=edge_density(g, loops=F), 
                                             density_d=ecount(g)/(sum(str_detect(names(V(g)), 'D'))*sum(str_detect(names(V(g)), 'A'))),
                                             dyad_mut=dyad_census(g)$mut, 
                                             dyad_null=dyad_census(g)$null, 
                                             triad_003=triad_census(g)[1], 
                                             triad_201=triad_census(g)[11], 
                                             transitivity=transitivity(g),
                                             centr=centr_degree(g)$centralization))
  graph_comp[s] <- components(g)
}
```

```{r head_stat, echo=F}
graph_stat
```

### 노드 및 연결 수

- D네트워크와 A네트워크 모두 드라마 장르에서 최대 노드수와 최대 연결수를 보였고, 서부극(웨스턴) 장르에서 최소 노드수와 최소 연결수를 보임
  - 드라마 장르에 포함된 영화가 4198개로가 가장 많고, 한 영화의 다수의 주연 배우가 출연
  - 가운데에 응집성이 큰 노드 집합이 있으며, 외곽을 구성하는 노드들 또한 조밀하게 형성되어 있음
  - 서부극 장르의 영화는 24개로 가장 적고, 눈으로 셀 수 있을 정도의 노드 수를 구성하고 있으며, 노트간의 특징은 크게 찾아보기 어려움

### 밀도

- D네트워크는 이부 네트워크이기 때문에 ecount를 가능한 최대 엣지 수로 나누는 방식으로 밀도 계산 (density_d)
- D네트워크와 A네트워크 모두 규모가 가장 작은 서부극 장르가 가장 밀도가 높은 것으로 나타남
  - 규모가 작아 형성 가능한 엣지 수가 적기 때문에 밀도가 높게 나온 것으로 추정
- 이와 반대로, 가장 규모가 큰 드라마 장르의 밀도가 가장 낮은 것으로 나타남

### 추이성

- D네트워크는 추이성을 구할 수 없는 구조(이부 네트워크)이므로 A네트워크에 대해서만 분석 진행
- 추이성이 가장 높게 나온 A네트워크는 다큐멘터리 장르
  - 삼각형 구조가 대부분을 차지하는 것을 통해 거의 전부의 배우가 서로 함께 작품을 진행한 경험이 있는 것으로 볼 수 있음
- 장르 특성상 추이성이 낮을 수밖에 없는 에로(성인물) 장르를 제외하고, 드라마 장르의 추이성이 가장 낮음
  - 노드 수가 가장 많아 삼각형 구조 형성 자체에 어려움이 있음

### 컴포넌트

```{r components}
comp_stat <- data.frame()
for (s in graph_names) {
  g <- get(s)
  comp <- graph_comp[s]
  top <- table(comp)[order(table(comp), decreasing = T)][1]
  comp_stat <- rbind(comp_stat, data.frame(graph=s, top=top, top_rate=top/vcount(g)))
}
```

```{r show_components, echo=F}
comp_stat[order(comp_stat$top_rate),]
```

- 네트워크 내 가장 큰 컴포넌트에 속해 있는 노드가 전체 노드 중에서 차지하는 비율 계산
- D네트워크와 A네트워크 모두 애니메이션 장르의 최대 컴포넌트 비율이 가장 높음 (78.2% / 73.2%)
  - 애니메이션 장르에 속한 감독과 배우가 가장 넓게 연결되어 있음
  - 해당 장르에서 특정 배우 또는 감독과 연락이 닿고 싶으면 70% 이상의 확률로 여러 다리를 건너 연락이 닿을 수 있음
- D네트워크에서는 다큐멘터리 장르(3.0%), A네트워크에서는 공포(4.5%)와 다큐멘터리 장르(4.5%)의 최대 컴포넌트 비율이 가장 작음
  - 다큐멘터리 장르의 경우 추이성이 가장 높았음에도 최대 컴포넌트 비율이 가장 작다는 의외의 결과가 나옴
  - 그래프를 자세히 살펴보면 그래프 전체가 대부분 4~5 노드의 작은 그룹의 조합으로 구성됨
  
### 장르별 가장 많은 관계자와 작업한 사람

- 장르별로 가장 많은 배우와 작업한 배우, 가장 많은 배우와 작업한 감독, 가장 많은 감독과 작업한 배우를 알아봄

```{r most_relation}
result <- data.frame()
topn <- 3
for (j in 1:(length(graph_names)/2)) {
  g <- get(graph_names[j*2-1])
  counts <- degree(g)[order(degree(g), decreasing = T)]
  ordered_names <- names(counts)
  # D는 가장 많은 배우와 함께 일한 감독, A는 가장 많은 감독과 일한 배우
  top_d <- ordered_names[str_detect(ordered_names, 'D')][1:topn] 
  top_a <- ordered_names[str_detect(ordered_names, 'A')][1:topn]
  id_d <- str_sub(top_d, 2)
  id_a <- str_sub(top_a, 2)
  counts_d <- counts[top_d]
  counts_a <- counts[top_a]
  names_d <- unique(staff[staff[['person_id']] %in% id_d,]$person_name)
  names_a <- unique(staff[staff[['person_id']] %in% id_a,]$person_name)
  
  g2 <- get(graph_names[j*2])
  counts2 <- degree(g2)[order(degree(g2), decreasing = T)]
  id2 <- names(counts2)
  top2 <- id2[1:topn]
  names2 <- unique(staff[staff[['person_id']] %in% top2,]$person_name)
  
  for (i in 1:topn) {
    result <- rbind(result, data.frame('장르'=str_sub(graph_names[j*2], 3),
                                       '순위'=i,
                                       '감독 with 배우'=paste0('(',counts_d[i], ') ', names_d[i]), 
                                       '배우 with 감독'=paste0('(',counts_a[i], ') ', names_a[i]), 
                                       '배우 with 배우'=paste0('(',counts2[top2[i]], ') ', names2[i])))
  } 
}
```

```{r show_most_relation, echo=F}
result
```

## 개선할 점

- 영화의 흥행을 의미할 만한 지표가 부족하여 네트워크를 형성할 때 단순히 함께 작업했다는 사실만으로 분석 진행
- 영화의 제작년도, 제작국가에 대한 데이터의 활용이 부족했음
- 통계치로부터의 깊은 의미 유도 부족
  - 배급사에 따른 배우의 케미 등 깊이 있는 분석을 하지 못한 부분에 아쉬움이 있음
  